import{_ as a,c as n,b as s,o as t}from"./app-Bb1tC85q.js";const i={};function l(p,e){return t(),n("div",null,e[0]||(e[0]=[s(`<h2 id="红黑树分析" tabindex="-1"><a class="header-anchor" href="#红黑树分析"><span>红黑树分析</span></a></h2><h3 id="红黑树性质" tabindex="-1"><a class="header-anchor" href="#红黑树性质"><span>红黑树性质</span></a></h3><p>1.每个节点要么为黑色要么为红色 2.根节点是黑色 3.叶子节点均为黑色(nil) 4.如果一个节点是红色的那么它的叶子节点必须是黑色的 5.从一个节点到其子孙节点的路径中所包含的黑色节点相同(也就是所谓黑高相同)</p><p>注意一个常见的误区是 红黑树必须一层红,一层黑。一个黑节点下面两个黑节点也允许. 黑 黑 黑 这种情况也可以存在</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>               [黑]</span></span>
<span class="line"><span>              /    \\</span></span>
<span class="line"><span>             /      \\</span></span>
<span class="line"><span>            /        \\</span></span>
<span class="line"><span>         [红]        [红]</span></span>
<span class="line"><span>        /    \\      /    \\</span></span>
<span class="line"><span>       /      \\    /      \\</span></span>
<span class="line"><span>    [黑]     [黑] [黑]    [黑]</span></span>
<span class="line"><span>   /    \\   /   \\/   \\  /    \\</span></span>
<span class="line"><span>  [nil][nil][nil]...</span></span>
<span class="line"><span>  //最底层无实际值的节点被称为叶子节点，其节点是黑色的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="红黑树的插入" tabindex="-1"><a class="header-anchor" href="#红黑树的插入"><span>红黑树的插入</span></a></h3><p>红黑树可以看成3阶段b树，也就是说其黑色节点可以提到其父节点的两边，在逻辑上三个节点看成一个b树节点 红黑树为了保持以上五条性质才能保证其nlogn的查找 红黑树被插入节点初始颜色是红色</p><p>1.插入情况1 &quot;B树节点未满&quot; 也就是说存在黑色非叶节点(有意义的节点)两个子节点至少有一个不存在的情况。那么直接插入即可。此时红黑树不需要调整 某子树: ... <br> 黑(1) / <br> nil(2) nil(3) 1的左右子节点是空的，所以可以任意插入</p><p>2.插入情况2 插入节点的父节点是红色</p><h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h3><p>定义一个转换操作 TRANSPLANT (T,u,v) 此函数目的是 用以v为根的子树替换以u为根的子树。在实际操作中 v通常为u的左右子树.(只处理u的父节点与v的关系不处理被删除节点的子节点的关系)</p><p>先梳理一下搜索树的删除</p><p>case1 被删除节点u没有左右孩子,直接删除(u=null,或者delete u 或者不管不同语言不同处理方式) case2 有左孩子无右孩子 直接把左子树拼到被删除节点u的位置 (处理与父节点的关系) case3 有右孩子无左孩子 直接把右子树拼到被删除节点u的位置 case4 同时有左右孩子 一般找中序遍历的后继节点(当然也可以找前驱) 先把后继取出(把找到的后继的右子树拼到后继节点v的位置上，相当于v被删除了) 把后继节点v拼到被删除节点u处 。这里说拼有些抽象 1.先处理v和u-&gt;right的关系,u-&gt;right 处理后结束v的右子树了,现在v就是掌管了原来u的右子树的节点了 2.用TRANSPLANT 处理v和u的父节点的关系(链接) 3.再单独处理u的左子树和v的关系(链接) 4.具体编程还需要处理被删除节点u的内存等操作</p><p>tips 后继节点在右子树上且后继节点没有左子树，因为有左子树,那么后继节点肯定比当前找到的节点还小在其左子树里,当前找到的节点肯定不是被删除节点的后继</p><p>现在来看下红黑树的删除 除了删除，还需要关联红黑树性质被满足</p>`,15)]))}const c=a(i,[["render",l],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/article/w4932sb0/","title":"redblack_tree","lang":"zh-CN","frontmatter":{"title":"redblack_tree","createTime":"2025/03/20 22:08:44","permalink":"/article/w4932sb0/","description":"红黑树分析 红黑树性质 1.每个节点要么为黑色要么为红色 2.根节点是黑色 3.叶子节点均为黑色(nil) 4.如果一个节点是红色的那么它的叶子节点必须是黑色的 5.从一个节点到其子孙节点的路径中所包含的黑色节点相同(也就是所谓黑高相同) 注意一个常见的误区是 红黑树必须一层红,一层黑。一个黑节点下面两个黑节点也允许. 黑 黑 黑 这种情况也可以存在 ...","head":[["meta",{"property":"og:url","content":"https://github.com/Yuzhiy05/Yuzhiy05.github.io/article/w4932sb0/"}],["meta",{"property":"og:title","content":"redblack_tree"}],["meta",{"property":"og:description","content":"红黑树分析 红黑树性质 1.每个节点要么为黑色要么为红色 2.根节点是黑色 3.叶子节点均为黑色(nil) 4.如果一个节点是红色的那么它的叶子节点必须是黑色的 5.从一个节点到其子孙节点的路径中所包含的黑色节点相同(也就是所谓黑高相同) 注意一个常见的误区是 红黑树必须一层红,一层黑。一个黑节点下面两个黑节点也允许. 黑 黑 黑 这种情况也可以存在 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-13T04:17:45.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-13T04:17:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redblack_tree\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-13T04:17:45.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"红黑树分析","slug":"红黑树分析","link":"#红黑树分析","children":[{"level":3,"title":"红黑树性质","slug":"红黑树性质","link":"#红黑树性质","children":[]},{"level":3,"title":"红黑树的插入","slug":"红黑树的插入","link":"#红黑树的插入","children":[]},{"level":3,"title":"删除","slug":"删除","link":"#删除","children":[]}]}],"readingTime":{"minutes":2.94,"words":882},"git":{"createdTime":1742830675000,"updatedTime":1752380265000,"contributors":[{"name":"ImoutoCon1999","email":"ImoutoCon1999@outlook.com","commits":3}]},"autoDesc":true,"filePathRelative":"3.datast_algo/redblack_tree.md","categoryList":[{"id":"0be4ff","sort":3,"name":"datast_algo"}],"bulletin":false}');export{c as comp,d as data};
