---
title: 搭建vscode-cpp环境
createTime: 2024/07/03 21:23:38
permalink: /article/jaovy4gg/
---
# VSCode 搭建cpp环境
## 准备工作
1.下载VScode
2.Windows环境下载mingw64  
[下载链接](https://github.com/trcrsired/llvm-releases)  
3.解压缩x86-64 w64-mingw32   
4.*D:\workfile\gcc15\x86_64-w64-mingw32\bin*与  
*D:\workfile\gcc15\x86_64-w64-mingw32\lib*   
*D:\workfile\gcc15\x86_64-w64-mingw32\lib32*
添加至用户环境变量*PATH*    
5.打开下载c++插件


##  Cmake搭配Vscode

### 前提介绍
1.CMakePresets.json：用于指定整个项目的构建细节，json中包含  
```c++
name
预设的名称，一般用表示平台或编译期的版本名字;

vendor
可选内容，提供供应商的信息，Cmake一般不管除非有所谓映射(不用管)

displayName
此预设的个性化名词(无关紧要)一般有编译期名字代替如"GCC 15.0.0 x86_64-w64-mingw32"

description
自定义的描述(无关紧要)一般使用本地编译期所在路径描述

steps
A required array of objects describing the steps of the workflow. The first step must be a configure preset, and all subsequent steps must be non- configure presets whose configurePreset field matches the starting configure preset. Each object may contain the following fields:

type
A required string. The first step must be configure. Subsequent steps must be either build, test, or package.

name
A required string representing the name of the configure, build, test, or package preset to run as this workflow step.
```
2.CmakeLists.txt：告诉Cmake如何构建你的项目


### 构建CmakeLists
1.打开Vscode的命令面板 (Ctrl+Shift+P) 并运行CMake: Quick Start命令  
2.输入项目名称，选择c++作为项目语言  
3.暂时选择`CTest`作为测试支持  
4.选择`Executable`作为项目类型时，创建包含`main`函数的`mian.cpp`文件 
Note:当然想要创建头文件或基础资源时可选择`Library`  


### 创建 CMakePresets.json 
1.选择 添加新的预设值和从编译器创建  
note:该扩展可自动扫描计算机上的工具包，并创建系统中发现的编译器列表。
2.根据你想要编译器选择
3.输入预设的名字
完成这些步骤后，您就拥有了一个完整的 hello world CMake 项目，其中包含以下文件:
`main.cpp`, `CMakeLists.txt`, and `CMakePresets.json`.



## 创建一个项目

`tasks.json` (构建指导)  
`launch.json` (debugger 设置)  
`c_cpp_properties.json` (编译器路径与智能感知设置)  


首次运行程序时，C++ 扩展会创建一个 tasks.json 文件，您可以在项目的 .vscode 文件夹中找到该文件。tasks.json 会存储您的构建配置

```json
{
  "tasks": [
    {
      "type": "cppbuild",
      "label": "C/C++: g++.exe build active file",
      "command": "C:\\msys64\\ucrt64\\bin\\g++.exe",
      "args": [
        "-fdiagnostics-color=always",
        "-g",
        "${file}",
        "-o",
        "${fileDirname}\\${fileBasenameNoExtension}.exe"
      ],
      "options": {
        "cwd": "${fileDirname}"
      },
      "problemMatcher": ["$gcc"],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Task generated by Debugger."
    }
  ],
  "version": "2.0.0"
}
```

# 使用cmake
## cmakelist配置
### 生成动态库
1.有如下目录结构 
``` 
>cmake_study  
    |          
    |__lib  
    |__testFunc  
        |__testFunc.c  
        |__test2.h
```
```cmake
# 新建变量SRC_LIST
set(SRC_LIST ${PROJECT_SOURCE_DIR}/testFunc/testFunc.c)

# 对 源文件变量 生成动态库 testFunc_shared
add_library(testFunc_shared SHARED ${SRC_LIST})
# 对 源文件变量 生成静态库 testFunc_static
add_library(testFunc_static STATIC ${SRC_LIST})

# 设置最终生成的库的名称
set_target_properties(testFunc_shared PROPERTIES OUTPUT_NAME "testFunc")
set_target_properties(testFunc_static PROPERTIES OUTPUT_NAME "testFunc")

# 设置库文件的输出路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
```

1.`add_library`：生成动态库或静态库  
  第1个参数：指定库的名字  
  第2个参数：决定是动态还是静态，如果没有就默认静态  
  第3个参数：指定生成库的源文件  
2.`set_target_properties`：设置最终生成的库的名称，还有其它功能，如设置库的版本号等等  
3.`LIBRARY_OUTPUT_PATH`：库文件的默认输出路径，这里设置为工程目录下的lib目录

前面使用set_target_properties重新定义了库的输出名称，如果不使用set_target_properties也可以，那么库的名称就是add_library里定义的名称，只是连续2次使用add_library指定库名称时（第一个参数），这个名称不能相同，而set_target_properties可以把名称设置为相同，只是最终生成的库文件后缀不同（一个是.so，一个是.a.win中为dll），这样相对来说会好看点 

### 链接库
有如下文件路径
```
cmake_study
    |
    |__bin
    |__build
    |__src
    |__test
        |__inc
        |   |__test1.h
        |__lib
            |__test2.lib
            |__tets2.dll
   cmakelist.txt
```
```cmake
# 输出bin文件路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)

# 将源代码添加到变量
set(src_list ${PROJECT_SOURCE_DIR}/src/main.c)

# 添加头文件搜索路径
include_directories(${PROJECT_SOURCE_DIR}/testFunc/inc)

# 在指定路径下查找库，并把库的绝对路径存放到变量里
find_library(TESTFUNC_LIB testFunc HINTS ${PROJECT_SOURCE_DIR}/testFunc/lib)

# 执行源文件
add_executable(main ${src_list})

# 把目标文件与库文件进行链接
target_link_libraries(main ${TESTFUNC_LIB})
```


PRIVATE 关键字表明 fmt 仅在生成 HelloWorld 时需要，不应传播到其他依赖项目
###  cmake 命令速览
cmake -Bbuild -GNinja -S.  以ninja生成 以 当前目录为源码 构建目录为build(如果没有就新建)

cmake -Bbuild -GNinja -S.. 在build文件夹下执行

ninja 在build文件夹下执行




